{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/prototype-vs-proto/","result":{"data":{"markdownRemark":{"html":"<h2><strong>prototype vs __proto__</strong></h2>\n<p class=\"text-time\">최초 업로드 2023-12-01 / 마지막 수정 2023-12-01</p>\n<p>JS는 모든 객체에서 <code>__proto__</code> 혹은 <code>Object.getPrototypeOf</code>로 <code>[[Prototype]]</code>내부 슬롯을 볼 수 있다.\r\n<code>__proto__</code>와는 사뭇 다른 <code>prototype</code>은 함수 객체에만 존재한다.</p>\n<ul>\n<li><span class=\"text-orange\">함수의 <code>.__proto__</code>는 본인이 <code>new</code>로 생성할 객체의 프로토타입을 반환</span>하고</li>\n<li><span class=\"text-orange\">함수의 <code>.prototype</code>는 언제나 <code>Function.prototype</code>을 반환</span>한다.</li>\n</ul>\n<p>고로, 어떤 함수 객체가 생성할 객체의 프로토타입 체인을 보고싶으면 <code>__proto__</code>가 아닌 <code>prototype</code>을 호출해야한다.\r\n아래 예시는 두 개의 차이점을 보기 위해 만들어보았다.</p>\n<br/>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">// create Animal\r\nfunction Animal(hp) {\r\n  this.alive = true;\r\n  this.hp = hp;\r\n}\r\n\r\nAnimal.prototype.eat = (food) =&gt; {\r\n  // arrow 함수는 [[Contructor]]가 없기에 메서드로 사용된다는 것을 강조한다.\r\n  this.hp += food;\r\n};\r\n\r\n// create Dog\r\nfunction Dog(hp, breed) {\r\n  Animal.call(this, hp);\r\n  this.abilities = [&quot;bark&quot;, &quot;sniff&quot;];\r\n  this.breed = breed;\r\n}\r\nDog.prototype = Object.create(Animal.prototype);\r\nDog.prototype.constructor = Dog;\r\n\r\n// create GermanShepherd\r\nfunction GermanShepherd(hp, strength) {\r\n  Dog.call(this, hp, &quot;German Shepherd&quot;);\r\n  this.strength = strength;\r\n}\r\nGermanShepherd.prototype = Object.create(Dog.prototype);\r\nGermanShepherd.prototype.constructor = GermanShepherd;\r\n\r\n// test objects\r\nconst dog1 = new Dog(100, &quot;a&quot;);\r\nconst gs1 = new GermanShepherd(100, 100);\r\n\r\n// structure check\r\nconsole.log(GermanShepherd.__proto__ === Function.prototype); // Function.prototype\r\nconsole.log(GermanShepherd.__proto__.__proto__ === Object.prototype); // Object.prototype\r\nconsole.log(\r\n  gs1.__proto__, // Dog { constructor: [Function: GermanShepherd] }\r\n  gs1.__proto__.__proto__, // Animal { constructor: [Function: Dog] }\r\n  gs1.__proto__.__proto__.__proto__, // { eat: [Function (anonymous)] }\r\n  gs1.__proto__.__proto__.__proto__.__proto__ // [Object: null prototype] {}\r\n);\r\nconsole.log(\r\n  GermanShepherd.prototype, // Dog { constructor: [Function: GermanShepherd] }\r\n  GermanShepherd.prototype.__proto__, // Animal { constructor: [Function: Dog] }\r\n  GermanShepherd.prototype.__proto__.__proto__, // { eat: [Function (anonymous)] }\r\n  GermanShepherd.prototype.__proto__.__proto__.__proto__ // [Object: null prototype] {}\r\n);</code>\n        </deckgo-highlight-code>\n<br/>\n<div class=\"image-container\">\r\n  <img class=\"md-image\" src=\"/images/prototype.png\" alt=\"next_js_caching_flow\"/>\r\n  <sub class>그림 1. 코드를 정리한 그래프</sub>\r\n</div>\n<br/>\n<p>함수 객체의 <code>prototype</code>은 언제나 <code>Function.prototype</code>을 가리키고 있다는 사실을 명심하자.</p>","frontmatter":{"date":"December 01, 2023","slug":"/blog/prototype-vs-proto","title":"prototype vs __proto__","subtitle":"__proto__는 상속느낌이고 prototype은 전수의 느낌이다."}}},"pageContext":{"id":"294b1d16-2181-5cec-8085-8ef1514dd0f2","frontmatter__slug":"/blog/prototype-vs-proto","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["1865044719","2228436175","326441978"],"slicesMap":{}}