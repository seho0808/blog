{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/prototype-vs-proto/","result":{"data":{"markdownRemark":{"html":"<h2><strong>prototype vs __proto__</strong></h2>\n<p class=\"text-time\">최초 업로드 2023-12-01 / 마지막 수정 2023-12-06</p>\n<p>JS는 모든 객체에서 <code>__proto__</code> 혹은 <code>Object.getPrototypeOf</code>로 <code>[[Prototype]]</code>내부 슬롯을 볼 수 있다.\r\n<code>__proto__</code>와는 사뭇 다른 <code>prototype</code>은 함수 객체에만 존재한다.</p>\n<ul>\n<li><span class=\"text-orange\">함수의 <code>.prototype</code>는 본인이 <code>new</code>로 생성할 객체의 프로토타입을 반환</span>하고</li>\n<li><span class=\"text-orange\">함수의 <code>.__proto__</code>는 따로 설정해주지 않으면 언제나 <code>Function.prototype</code>을 반환</span>한다.</li>\n</ul>\n<p>고로, 어떤 함수 객체가 생성할 객체의 프로토타입 체인을 보고싶으면 <code>__proto__</code>가 아닌 <code>prototype</code>을 호출해야한다.</p>\n<p>자세히 생각해보면 자연스러운 흐름이다. 보통 프로토타입 객체는 <code>constructor</code>를 가지고 있는 객체이다. <code>constructor</code>필드는 해당 프로토타입을\r\n기반으로 객체를 만들면 만들어지는 것을 보여주는 공장 라인과도 같다. 그렇다면 함수 객체의 프로토타입은 반드시 <span class=\"text-orange\">함수를 만드는</span> <code>constructor</code>를 가지고 있어야하며,\r\n함수 객체의 <code>__proto__</code>가 <code>Function.prototype</code>이 되는 것이 매우 자연스럽다는 것을 보여준다. 함수에 <code>__proto__</code>만 있고 <code>prototype</code>이 없다면 함수 객체가 만들어내는 객체의 프로토타입 체인을\r\n확인할 길이 없으니, <code>prototype</code>이 존재하는 것 또한 자연스러워진다.</p>\n<p>아래 예시는 두 개의 차이점을 직접 보기 위해 만들어보았다.</p>\n<br/>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">// create Animal\r\nfunction Animal(hp) {\r\n  this.alive = true;\r\n  this.hp = hp;\r\n}\r\n\r\nAnimal.prototype.eat = (food) =&gt; {\r\n  // arrow 함수는 [[Contructor]]가 없기에 메서드로 사용된다는 것을 강조한다.\r\n  this.hp += food;\r\n};\r\n\r\n// create Dog\r\nfunction Dog(hp, breed) {\r\n  Animal.call(this, hp);\r\n  this.abilities = [&quot;bark&quot;, &quot;sniff&quot;];\r\n  this.breed = breed;\r\n}\r\nDog.prototype = Object.create(Animal.prototype);\r\nDog.prototype.constructor = Dog;\r\n\r\n// create GermanShepherd\r\nfunction GermanShepherd(hp, strength) {\r\n  Dog.call(this, hp, &quot;German Shepherd&quot;);\r\n  this.strength = strength;\r\n}\r\nGermanShepherd.prototype = Object.create(Dog.prototype);\r\nGermanShepherd.prototype.constructor = GermanShepherd;\r\n\r\n// test objects\r\nconst dog1 = new Dog(100, &quot;a&quot;);\r\nconst gs1 = new GermanShepherd(100, 100);\r\n\r\n// structure check\r\nconsole.log(GermanShepherd.__proto__ === Function.prototype); // Function.prototype\r\nconsole.log(GermanShepherd.__proto__.__proto__ === Object.prototype); // Object.prototype\r\nconsole.log(\r\n  gs1.__proto__, // Dog { constructor: [Function: GermanShepherd] }\r\n  gs1.__proto__.__proto__, // Animal { constructor: [Function: Dog] }\r\n  gs1.__proto__.__proto__.__proto__, // { eat: [Function (anonymous)] }\r\n  gs1.__proto__.__proto__.__proto__.__proto__ // [Object: null prototype] {}\r\n);\r\nconsole.log(\r\n  GermanShepherd.prototype, // Dog { constructor: [Function: GermanShepherd] }\r\n  GermanShepherd.prototype.__proto__, // Animal { constructor: [Function: Dog] }\r\n  GermanShepherd.prototype.__proto__.__proto__, // { eat: [Function (anonymous)] }\r\n  GermanShepherd.prototype.__proto__.__proto__.__proto__ // [Object: null prototype] {}\r\n);</code>\n        </deckgo-highlight-code>\n<br/>\n<div class=\"image-container\">\r\n  <img class=\"md-image\" src=\"/images/prototype.png\" alt=\"next_js_caching_flow\"/>\r\n  <sub class>그림 1. 코드를 정리한 그래프</sub>\r\n</div>\n<br/>\n<p>함수 객체의 <code>__proto__</code>는 수동으로 설정해주지 않는 이상 언제나 <code>Function.prototype</code>을 가리키고 있다는 사실을 명심하자.</p>\n<h4><strong>클래스의 경우</strong></h4>\n<p>클래스의 경우 함수 객체이지만 <code>__proto__</code>가 상위 클래스를 가리킨다. 생성자 함수에서 위 코드 처럼 pseudo-classical inheritance를 하는 것과는 정반대로,\r\n클래스 함수 객체는 extend할 때 마다 상위 클래스 함수 객체를 가리키게된다. 그래서 상위 클래스의 스태틱 함수를 접근할 수 있다. 그래서 클래스가 생성하는 객체들끼리의\r\n프로토타입 체인과 클래스 자체의 프로토타입 체인, 이 두 가지 체이 존재한다.</p>\n<p><span class=\"text-orange\">클래스는 프로토타입 체인이 두 개이고, 생성자 함수로 만든 pseudo-classical inheritance는 프로토타입 체인이 하나이다.</span></p>","frontmatter":{"date":"December 01, 2023","slug":"/blog/prototype-vs-proto","title":"prototype vs __proto__","subtitle":"__proto__는 상속느낌이고 prototype은 전수의 느낌이다."}}},"pageContext":{"id":"294b1d16-2181-5cec-8085-8ef1514dd0f2","frontmatter__slug":"/blog/prototype-vs-proto","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["1865044719","2228436175","326441978"],"slicesMap":{}}