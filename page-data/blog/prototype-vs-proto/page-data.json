{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/prototype-vs-proto/","result":{"data":{"markdownRemark":{"html":"<h2><strong>prototype vs __proto__</strong></h2>\n<p class=\"text-time\">최초 업로드 2023-12-01 / 마지막 수정 2023-12-14</p>\n<p>JS는 모든 객체에서 <code>__proto__</code> 혹은 <code>Object.getPrototypeOf</code>로 <code>[[Prototype]]</code>내부 슬롯을 볼 수 있다.\n<code>__proto__</code>와는 사뭇 다른 <code>prototype</code>은 함수 객체에만 존재한다.</p>\n<ul>\n<li><span class=\"text-orange\">함수의 <code>.prototype</code>는 본인이 <code>new</code>로 생성할 객체의 프로토타입을 반환</span>하고</li>\n<li><span class=\"text-orange\">함수의 <code>.__proto__</code>는 따로 설정해주지 않으면 언제나 <code>Function.prototype</code>을 반환</span>한다.</li>\n</ul>\n<p>고로, 어떤 함수 객체가 생성할 객체의 프로토타입 체인을 보고싶으면 <code>__proto__</code>가 아닌 <code>prototype</code>을 호출해야한다.</p>\n<p>자세히 생각해보면 자연스러운 흐름이다. 보통 프로토타입 객체는 <code>constructor</code>를 가지고 있는 객체이다. <code>constructor</code>필드는 해당 프로토타입을\n기반으로 객체를 만들면 만들어지는 것을 보여주는 공장 라인과도 같다. 그렇다면 함수 객체의 프로토타입은 반드시 <span class=\"text-orange\">함수를 만드는</span> <code>constructor</code>를 가지고 있어야하며,\n함수 객체의 <code>__proto__</code>가 <code>Function.prototype</code>이 되는 것이 매우 자연스럽다는 것을 보여준다. 함수에 <code>__proto__</code>만 있고 <code>prototype</code>이 없다면 함수 객체가 만들어내는 객체의 프로토타입 체인을\n확인할 길이 없으니, <code>prototype</code>이 존재하는 것 또한 자연스러워진다.</p>\n<p>아래 예시는 두 개의 차이점을 직접 보기 위해 만들어보았다.</p>\n<br/>\n<pre><code class=\"language-javascript\">// create Animal\nfunction Animal(hp) {\n  this.alive = true;\n  this.hp = hp;\n}\n\nAnimal.prototype.eat = (food) => {\n  // arrow 함수는 [[Contructor]]가 없기에 메서드로 사용된다는 것을 강조한다.\n  this.hp += food;\n};\n\n// create Dog\nfunction Dog(hp, breed) {\n  Animal.call(this, hp);\n  this.abilities = [\"bark\", \"sniff\"];\n  this.breed = breed;\n}\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog;\n\n// create GermanShepherd\nfunction GermanShepherd(hp, strength) {\n  Dog.call(this, hp, \"German Shepherd\");\n  this.strength = strength;\n}\nGermanShepherd.prototype = Object.create(Dog.prototype);\nGermanShepherd.prototype.constructor = GermanShepherd;\n\n// test objects\nconst dog1 = new Dog(100, \"a\");\nconst gs1 = new GermanShepherd(100, 100);\n\n// structure check\nconsole.log(GermanShepherd.__proto__ === Function.prototype); // Function.prototype\nconsole.log(GermanShepherd.__proto__.__proto__ === Object.prototype); // Object.prototype\nconsole.log(\n  gs1.__proto__, // Dog { constructor: [Function: GermanShepherd] }\n  gs1.__proto__.__proto__, // Animal { constructor: [Function: Dog] }\n  gs1.__proto__.__proto__.__proto__, // { eat: [Function (anonymous)] }\n  gs1.__proto__.__proto__.__proto__.__proto__ // [Object: null prototype] {}\n);\nconsole.log(\n  GermanShepherd.prototype, // Dog { constructor: [Function: GermanShepherd] }\n  GermanShepherd.prototype.__proto__, // Animal { constructor: [Function: Dog] }\n  GermanShepherd.prototype.__proto__.__proto__, // { eat: [Function (anonymous)] }\n  GermanShepherd.prototype.__proto__.__proto__.__proto__ // [Object: null prototype] {}\n);\n</code></pre>\n<br/>\n<div class=\"image-container\">\n  <img class=\"md-image\" src=\"https://d1ykeqyorqdego.cloudfront.net/new-assets/prototype.png\" alt=\"next_js_caching_flow\"/>\n  <sub class>그림 1. 코드를 정리한 그래프</sub>\n</div>\n<br/>\n<p>함수 객체의 <code>__proto__</code>는 수동으로 설정해주지 않는 이상 언제나 <code>Function.prototype</code>을 가리키고 있다는 사실을 명심하자.</p>\n<h4><strong>클래스의 경우</strong></h4>\n<p>위의 방식도 pseudo-classical inheritance이고, class로 구현하는 것도 pseudo-classical inheritance라고 한다. 근데 구현에 따라서 프로토타입 체인 갯수가 다르다.</p>\n<p><span class=\"text-orange\">클래스는 프로토타입 체인이 두 개이고, 위 방식의 함수들로 만든 pseudo-classical inheritance는 프로토타입 체인이 하나이다.</span></p>\n<br/>\n<p><strong>수정 사항</strong></p>\n<p>2023-12-14: 이틀전 면접 보면서 pseudo-classical inheritance를 내가 제대로 알고 있는게 맞나 끝나고 확인해봤는데, 잘못알고 있어서 글을 대폭 수정함.</p>","frontmatter":{"date":"December 01, 2023","slug":"/blog/prototype-vs-proto","title":"prototype vs __proto__","subtitle":"__proto__는 상속느낌이고 prototype은 전수의 느낌이다."}}},"pageContext":{"id":"ca867205-4026-53eb-b1c6-a889a9bdaba4","frontmatter__slug":"/blog/prototype-vs-proto","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["1865044719","2228436175","326441978"],"slicesMap":{}}