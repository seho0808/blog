{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/event-loop-examples/","result":{"data":{"markdownRemark":{"html":"<h2><strong>이벤트 루프 예시 코드</strong></h2>\n<p class=\"text-time\">최초 업로드 2023-12-04 / 마지막 수정 2023-12-04</p>\n<p>이벤트 루프를 직접 눈으로 확인하기 위해 예시 세 가지를 만들어보았다.</p>\n<br/>\n<pre><code class=\"language-javascript\">// 예시 1\nfunction foo() {\n  for (let i = 0; i &#x3C; 20000; i++) {\n    console.log(i);\n  }\n}\n\nfunction bar() {\n  console.log(\"done\");\n}\n\nsetTimeout(bar, 0);\nfoo();\n</code></pre>\n<br/>\n<p>예시 1은 브라우저와 node에서 모두 잘 작동한다. 20000개의 아웃풋이 다 나올 때까지 bar이 기다린다.\nfoo의 아웃풋의 갯수를 늘리면 bar의 \"done\"도 그만큼 늦게 로깅된다. setTimeout이 0일 때 4ms의 최소시간으로\n초기화된다고 한다. 그런데 블로킹 중인 실행 컨텍스트가 있으면 태스크 큐에 완료된 작업이 있어도 계속 기다려야한다. 이를 직관적으로 볼 수 있다.</p>\n<br/>\n<pre><code class=\"language-html\">&#x3C;!-- 예시 2 -->\n&#x3C;!DOCTYPE html>\n&#x3C;html>\n  &#x3C;head> &#x3C;/head>\n\n  &#x3C;body>\n    &#x3C;style>\n      .box {\n        width: 200px;\n        height: 200px;\n        background-color: green;\n      }\n    &#x3C;/style>\n    &#x3C;div class=\"box\">&#x3C;/div>\n\n    &#x3C;button onclick=\"print20000();\">run console log&#x3C;/button>\n\n    &#x3C;button onclick=\"flipColor();\">flip box color&#x3C;/button>\n\n    &#x3C;script>\n      function print20000() {\n        for (let i = 0; i &#x3C; 200000; i++) {\n          console.log(i);\n        }\n      }\n\n      function flipColor() {\n        const elem = document.querySelector(\".box\");\n        const curr = elem.style.backgroundColor;\n        if (curr === \"\" || curr === \"green\") {\n          elem.style.backgroundColor = \"blue\";\n        } else {\n          elem.style.backgroundColor = \"green\";\n        }\n      }\n    &#x3C;/script>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<br/>\n<p>예시 2에서는 Timer함수 말고 DOM API로 블로킹이 발생하는지 시험해보았다. 결과는 생각과는 조금 달랐다.\n지금 <code>print20000</code>에 있는 i의 최대치가 <code>200_000</code>으로 <code>20_000</code> 보다 10배 큰 상태인데, 이는 조금 더 현저하게\n딜레이를 주기위해 늘려놓은 것이다. 20,000으로 설정 => run console log 클릭 => flip box color 클릭을 하면\nconsole log가 다 나오기 전에 box color이 거의 동시다발적으로 바뀌어버리는것을 볼 수 있다. 반대로 200,000으로 설정 => run console log 클릭 => flip box color 클릭을 하면 console log가 다 나오기 전에 box color이 변하지만 동시다발적이진 않고 몇 초간 기다려야한다.</p>\n<p>여기서 볼 수 있는 것은 console log도 Web API이기 때문에 200,000개의 로깅 작업을 V8에서 브라우저에 넘겨준 직후 태스크 큐에서 작업을 받아서 처리할 수 있고, 이와 동시다발적으로 브라우저는 V8에서 넘겨 받은 console log 프린트 작업을 비동기적으로 처리할 수 있다는 것이다.</p>\n<p>아래 그림은 해당 프로세스를 정리한 플로우이다.</p>\n<br/>\n<div class=\"image-container\">\n  <img class=\"md-image\" src=\"https://d1ykeqyorqdego.cloudfront.net/new-assets/event-loop-ex.png\" alt=\"event-loop-example-flow\"/>\n  <sub class>그림 1. 이벤트 루프 플로우</sub>\n</div>\n<br/>\n<p>위의 그래프처럼 V8에서 브라우저로 API를 쏴주면 브라우저에서는 멀티스레드로 작동하기 때문에 위와 같이 <code>flipColor</code>이 <code>print20000</code>보다 작동이 빠르게 멈추었다고 생각했다. V8에서 정확히 어떤 타이밍에 브라우저로 넘겨주는지 알 수 있으면 더욱 좋을 것 같다고 생각하여 코드를 조금 수정해보았다. 아래 코드에서는 box2를 이용해 <code>print20000</code>의 for loop <code>console.log</code>가 브라우저의 로깅보다 훨씬 빠르다는 것을 증명한다. <code>box2</code>가 브라우저 dev tool에 나오는 로깅이 종료되기 훨씬 이전에 변경되고, 그와 동시에(!) <code>flipColor</code>이 실행된다.\n고로 위의 이벤트 루프 플로우가 맞았음을 볼 수 있다.</p>\n<br/>\n<pre><code class=\"language-html\">&#x3C;!-- 예시 3 -->\n&#x3C;!DOCTYPE html>\n&#x3C;html>\n  &#x3C;head> &#x3C;/head>\n\n  &#x3C;body>\n    &#x3C;style>\n      .box {\n        width: 200px;\n        height: 200px;\n        background-color: green;\n      }\n      .box2 {\n        width: 0px;\n        height: 0px;\n        background-color: grey;\n      }\n    &#x3C;/style>\n    &#x3C;div class=\"box\">&#x3C;/div>\n    &#x3C;div class=\"box2\">&#x3C;/div>\n\n    &#x3C;button onclick=\"print20000();\">run console log&#x3C;/button>\n\n    &#x3C;button onclick=\"flipColor();\">flip box color&#x3C;/button>\n\n    &#x3C;script>\n      function print20000() {\n        for (let i = 0; i &#x3C; 200000; i++) {\n          console.log(i);\n        }\n        // box2로 print20000이 끝나는 시점을 체크할 수 있다.\n        const elem = document.querySelector(\".box2\");\n        elem.style.width = \"200px\";\n        elem.style.height = \"200px\";\n      }\n\n      function flipColor() {\n        const elem = document.querySelector(\".box\");\n        const curr = elem.style.backgroundColor;\n        if (curr === \"\" || curr === \"green\") {\n          elem.style.backgroundColor = \"blue\";\n        } else {\n          elem.style.backgroundColor = \"green\";\n        }\n      }\n    &#x3C;/script>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>","frontmatter":{"date":"December 01, 2023","slug":"/blog/event-loop-examples","title":"Event Loop Examples","subtitle":"이벤트 루프 예시 코드"}}},"pageContext":{"id":"cab82f8c-c1a7-5f89-98b4-357f2f5d7fea","frontmatter__slug":"/blog/event-loop-examples","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["1865044719","2228436175","326441978"],"slicesMap":{}}