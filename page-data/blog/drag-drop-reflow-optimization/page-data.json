{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/drag-drop-reflow-optimization/","result":{"data":{"markdownRemark":{"html":"<h2><strong>드래그 드랍 리플로우 최적화</strong></h2>\n<p class=\"text-time\">최초 업로드 2024-04-11 / 마지막 수정 2024-04-11</p>\n<div class=\"video-container\">\n  <video src=\"https://d1ykeqyorqdego.cloudfront.net/new-assets/dnd-reflow/main-vid.mp4\" controls></video>\n  <sub class>영상 1. 순수 React로 만든 dnd</sub>\n</div>\n<p>최근 모 회사의 과제로 React로 dnd를 만들어보았다. 부드러운 UX를 만드는 것이 생각보다 매우 어려웠는데(<del>리페인트 맞추기 + 그리디 구현으로 인해 장장 40시간의 여정</del>), 나름 뿌듯했다. 근데 다 만들고 보니 리플로우 관련해서 큰 문제가 있나 싶어서 좀 파봤다.</p>\n<p>아래 코드를 보면 딱봐도 리플로우가 엄청 발생할 것처럼 생겼다. 그래서 코드를 짜면서도 계속 리플로우 발생을 줄이기 위해 batch로 스타일을 적용시키고 싶었는데, 여러 요소에 한 번에 클래스이름이나 스타일을 적용하는 DOM API가 없어서 오또케를 외치며 그냥 최대한 할 수 있는만큼 단순한 DOM Manipulation을 적용했었다.</p>\n<br/>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">/**\n * Card들의 Translate을 계산해줍니다.\n * @param droppable translate를 계산하고 적용시킬 droppable. 현재 드래그 중인 Card 위치에 있는 droppable입니다.\n * @param card 드래그 중인 Card\n * @param initial pointerdown 후 첫 setDroppableTranslates 호출인지 확인.\n */\nfunction setDroppableTranslatesLinear(\n  droppable: HTMLElement,\n  card: HTMLElement,\n  initial: boolean\n) {\n  const children = Array.from(droppable.children) as HTMLElement[];\n  let orderIdx = 0;\n  const cardRect = card.getBoundingClientRect();\n  const cardBottomY = cardRect.top + cardRect.height;\n  // 이렇게 순회해서 하나씩 style을 직접 건드리면 리플로우가 여러 번 발생할 것 같았음.\n  children.forEach((c, idx) =&gt; {\n    if (c === card) return;\n    if (c.className === &quot;droppable-placeholder&quot;) return;\n    const r = c.getBoundingClientRect();\n    const childBottomY = r.top + r.height;\n    if (cardBottomY &gt; childBottomY) {\n      c.style.transform = ``;\n      orderIdx++;\n    } else {\n      let styleString = `transform: translate(0, ${getEmptySpaceWithGap(\n        card\n      )}px);`;\n      if (!initial) styleString += &quot;transition: 0.25s&quot;;\n      c.setAttribute(&quot;style&quot;, styleString);\n    }\n  });\n//...</code>\n        </deckgo-highlight-code>\n<br/>\n<p>그래서 프로젝트 끝난 며칠 뒤에 다시 조사를 좀 해봤다. 근데 생각보다 흥미로운 사실 몇 가지를 발견했다.</p>\n<ol>\n<li>\n<p>getComputedStyle, getBoundingClientRect, offsetHeight, scrollTop 등 현재 UI에서 read하는 오퍼레이션도 리플로우(레이아웃)을 발생시킨다고 한다!!!!!!!</p>\n</li>\n<li>\n<p>dom read끼리 모아주고 write 끼리 모아주어서 레이아웃 쓰래싱이라는 것을 해결해주어야한다고 한다...</p>\n</li>\n</ol>\n<p>위 사실을 무수한 소스에서 읽고 (링크가 많아서 페이지 맨 아래에 두었다.) 크롬 데브 모드로 진입해보았다.</p>\n<div class=\"image-container\">\n  <img class=\"md-image\" src=\"https://d1ykeqyorqdego.cloudfront.net/new-assets/dnd-reflow/sc1.png\" alt=\"jpg rock\">\n  <sub class=\"\">그림 1. 16.7ms 프레임 단위로 pointermove가 핸들링되는 모습</sub>\n</div>\n<p>일단 보면 60hz에 맞춘 16.7ms마다 pointermove가 트리거 되는 것을 볼 수가 있다. (좀 의문인거는 내 화면은 144hz인데 브라우저 pointermove, mousemove같은 이벤트 처리는 디폴트로 16.7ms인가보다. css 애니메이션 자체는 144hz로 일어나는 것 같다.) 내가 50ms 쓰로틀링 처리를 해두어서 실제 처리는 3~4번의 pointermove마다 일어난다. 위 그림에 보면 1번 프레임은 뭐가 많고 2,3,4는 적고 5가 다시 좀 많다. 5번이 그 스로틀링 쿨이 돌아서 다시 트리거 되는 부분이다. 이제 그 첫 1프레임을 확대해보자.</p>\n<div class=\"image-container\">\n  <img class=\"md-image\" src=\"https://d1ykeqyorqdego.cloudfront.net/new-assets/dnd-reflow/sc2.png\" alt=\"jpg rock\">\n  <sub class=\"\">그림 2. 첫 pointermove 내의 getDroppableTranslatesLinear가 4ms가 걸리는 모습</sub>\n</div>\n<p>첫 pointermove에서는 O(n)으로 해당 Droppable의 모든 자식들의 Translate이 적용된다. 쉽게 설명하자면 Done 목록에서 하나의 카드를 드래그 시작하면 나머지 Done 목록의 모든 자식들이 빠진 카드의 빈 공간 만큼 아래로 Translate되는 것이다. 이걸 적용하는 코드가 위에 내가 4.38ms로 하이라이트한 <code>getDroppableTranslatesLinear</code>이다. 그리고 이 함수는 위에서 소스 코드로도 설명했던 코드다. 문제는 보라색 점들이 무수히 찍혀있는 것들이다. <code>setAttribute</code>, <code>getBoundingClientRect</code>에 의해 트리거된 무수한 보라색 점들이 모두 레이아웃(리플로우)이다. 내가 해당 스크린샷을 찍을 때는 To-dos 목록에 34개의 카드를 넣어두었는데, 카드 수를 늘릴 수록 레이아웃 개수도 늘어나고 4.38ms도 더 큰 숫자가 된다.</p>\n<p>그래서 수 많은 블로그들에서 읽은 \"Layout Thrashing\"이라는 것을 완화하기 위해 O(n)으로 모든 요소의 <code>getBoundingClientRect</code>를 먼저 읽은(dom read operation) 후 스타일들을 다시 처음부터 순회하며 적용(dom write operation)해주었다.</p>\n<br/>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">// 변경 전\nfunction setDroppableTranslatesLinear(\n  droppable: HTMLElement,\n  card: HTMLElement,\n  initial: boolean\n) {\n  const children = Array.from(droppable.children) as HTMLElement[];\n  let orderIdx = 0;\n  const cardRect = card.getBoundingClientRect();\n  const cardBottomY = cardRect.top + cardRect.height;\n  children.forEach((c, idx) =&gt; {\n    if (c === card) return;\n    if (c.className === &quot;droppable-placeholder&quot;) return;\n    const r = c.getBoundingClientRect(); // O(1) read 연산\n    const childBottomY = r.top + r.height;\n    if (cardBottomY &gt; childBottomY) {\n      c.style.transform = ``; // O(1) write 연산\n      orderIdx++;\n    } else {\n      let styleString = `transform: translate(0, ${getEmptySpaceWithGap(\n        card\n      )}px);`;\n      if (!initial) styleString += &quot;transition: 0.25s&quot;;\n      c.setAttribute(&quot;style&quot;, styleString); // O(1) write 연산\n    }\n  });\n//...\n\n// 변경 후\nfunction setDroppableTranslatesLinear(\n  droppable: HTMLElement,\n  card: HTMLElement,\n  initial: boolean\n) {\n  const children = Array.from(droppable.children) as HTMLElement[];\n  let orderIdx = 0;\n  const cardRect = card.getBoundingClientRect();\n  const cardBottomY = cardRect.top + cardRect.height;\n  const rects = children.map((c) =&gt; c.getBoundingClientRect()); // O(n) read 연산\n  children.forEach((c, idx) =&gt; {\n    if (c === card) return;\n    if (c.className === &quot;droppable-placeholder&quot;) return;\n    const childBottomY = rects[idx].top + rects[idx].height;\n    if (cardBottomY &gt; childBottomY) {\n      c.style.transform = ``; // O(1) write 연산\n      orderIdx++;\n    } else {\n      let styleString = `transform: translate(0, ${getEmptySpaceWithGap(\n        card\n      )}px);`;\n      if (!initial) styleString += &quot;transition: 0.25s&quot;;\n      c.setAttribute(&quot;style&quot;, styleString); // O(1) write 연산\n    }\n  });\n//...</code>\n        </deckgo-highlight-code>\n<br/>\n<p>자 그래서 얼마나 성능 개선이 되었는지가 궁금할 것이다. 놀랍게도 아무런 변화가 없었다...ㅋㅋ 아마 \"O(n)으로 두 번 순회하는 코스트 === read write을 batch로 각각 적용 시켜서 얻는 리플로우 개선\"인듯하다. 만약 아래 코드 처럼 단 한 번의 read로 줄인다면 무조건 개선이겠지만, 위의 내 코드의 경우에는 세 네번 이상 실험했는데도 4.00ms 대의 실행속도가 변하지 않았다.</p>\n<br/>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">//// 진짜로 무조건 개선되는 코드 (아래 링크 마다 똑같은 코드가 다 있습니다. 최초 원본은 web.dev 사이트인 것으로 추정됨.)\nfunction resizeAllParagraphs() {\n  const box = document.getElementById(&quot;box&quot;);\n  const paragraphs = document.querySelectorAll(&quot;.paragraph&quot;);\n\n  for (let i = 0; i &lt; paragraphs.length; i += 1) {\n    paragraphs[i].style.width = box.offsetWidth + &quot;px&quot;;\n  }\n}\n// 레이아웃 스래싱을 개선한 코드\nfunction resizeAllParagraphs() {\n  const box = document.getElementById(&quot;box&quot;);\n  const paragraphs = document.querySelectorAll(&quot;.paragraph&quot;);\n  const width = box.offsetWidth;\n\n  for (let i = 0; i &lt; paragraphs.length; i += 1) {\n    paragraphs[i].style.width = width + &quot;px&quot;;\n  }\n}</code>\n        </deckgo-highlight-code>\n<br/>\n<p>결론적으로 나의 최적화 작업은 실패로 돌아갔다. 언젠가 또 더 큰 깨달음을 얻어서 코드를 다시 진화시킬 수 있지 않을까 싶다.</p>\n<p>실용성으로만 치자면 reflow 총합이 8ms 언저리 이내로 일어나면 하나의 프레임 이내에 모든 것을 처리할 수 있을 것이다. 그리고 다른 비동기처리 함수들도 처리할 것을 생각하면 16.67ms에서 한 3ms 이상 정도의 오버헤드를 남겨두는 것은 필수적으로 필요해보인다.</p>\n<br/>\n<p>참고자료:</p>\n<ul>\n<li>\n<p><a href=\"https://gist.github.com/paulirish/5d52fb081b3570c81e3a\">What forces Layout Thrashing</a></p>\n</li>\n<li>\n<p><a href=\"https://web.dev/articles/avoid-large-complex-layouts-and-layout-thrashing\">Avoid Layout Thrashing</a></p>\n</li>\n<li>\n<p><a href=\"https://csstriggers.com/\">cssTriggers list</a></p>\n</li>\n<li>\n<p><a href=\"https://velog.io/@nuo/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%B5%9C%EC%A0%81%ED%99%94\">gyujae님의 블로그</a></p>\n</li>\n<li>\n<p><a href=\"https://ui.toast.com/fe-guide/ko_PERFORMANCE\">Toast UI 포트스</a></p>\n</li>\n</ul>","frontmatter":{"date":"April 11, 2024","slug":"/blog/drag-drop-reflow-optimization","title":"드래그 드랍 리플로우 최적화","subtitle":"드래그 드랍 리플로우 최적화"}}},"pageContext":{"id":"427669f2-bbe9-5ddb-8bd1-4b31269c62ad","frontmatter__slug":"/blog/drag-drop-reflow-optimization","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["1865044719","2228436175","326441978"],"slicesMap":{}}