{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/effective-typescript-review/","result":{"data":{"markdownRemark":{"html":"<h2><strong>이펙티브 타입스크립트</strong></h2>\n<p class=\"text-time\">최초 업로드 2023-01-14 / 마지막 수정 2023-01-14</p>\n<br/>\n<p>이펙티브 타입스크립트 공부하며 인상적이었던 내용을 정리하려고 한다.</p>\n<br/>\n<h3><strong>아이템 7 - 타입 유니온/인터섹션</strong></h3>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">interface A {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\ninterface B {\r\n  y: number;\r\n  z: number;\r\n}\r\n\r\ntype temp1 = keyof (A | B); // &#39;y&#39;\r\ntype temp2 = keyof A &amp; keyof B; // &#39;y&#39;\r\ntype temp3 = keyof (A &amp; B); // &#39;x&#39; | &#39;y&#39; | &#39;z&#39;\r\ntype temp4 = keyof A | keyof B; // &#39;x&#39; | &#39;y&#39; | &#39;z&#39;\r\n\r\nconst v1: A &amp; B = {\r\n  x: 1,\r\n  y: 1,\r\n  z: 1,\r\n};\r\n\r\nconst v2: A &amp; B = {\r\n  x: 1,\r\n  y: 1,\r\n  z: 1,\r\n  s: 10, // 내 린터는 오류라고 하지만, 책에는 괜찮다고 나와있다. ts 설정 차이인지 버전 차이인지 아직 모르겠다.\r\n};</code>\n        </deckgo-highlight-code>\n<br/>\n<p><code>A | B</code>와 <code>A &#x26; B</code>가 타입스크립트에서는 반대로 쓰인다. 이 점을 명심하자. <code>\"a\" | \"b\"</code> 와 <code>A | B</code>가 다르게 작동한다.\r\n책에서는 가독성을 높이기 위해 extends를 쓰라고 한다. 그리고 extends를 쓸 때, 집합을 보듯이 봐야 잘 읽힌다고 나와있다.</p>\n<br/>\n<h3><strong>아이템 8 - 값 typeof vs 타입 typeof</strong></h3>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">class Car {\r\n  width: 10;\r\n  height: 10;\r\n}\r\n\r\nconst carInstance: Car = new Car(); // 방식 1: 맞음.\r\nconst carInstance2: InstanceType&lt;typeof Car&gt; = new Car(); // 방식 2: 맞음.\r\nconst carInstance3: typeof Car = new Car(); // 오류. typeof Car은 생성자 타입이다.</code>\n        </deckgo-highlight-code>\n<br/>\n<p><code>Car</code>은 인스턴스 타입을 가리킨다. <code>new Car()</code>로 생성된 인스턴스의 타입이다. <code>typeof Car</code>은 <code>Car</code> 클래스의 생성자 타입이다.\r\n<code>InstanceType&#x3C;생성자 타입></code>을 통해 다시 인스턴스 타입으로 돌려놓을 수 있다.</p>\n<br/>\n<h3><strong>아이템 9 - 단언 보다 선언 쓰기</strong></h3>\n<p>단언이 꼭 필요한 경우에서 내가 며칠 전에 썼던 정확한 유스케이스가 나와서 반가웠다.</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">document.querySelector(&quot;#myButton&quot;).addEventListener(&quot;click&quot;, (e) =&gt; {\r\n  e.currentTarget; // EventTarget type은 너무 broad한 타입이다.\r\n  const button = e.currentTarget as HTMLButtonElement; // 이제 HTMLButtonElement에서 구현되어있는 필드를 사용할 수 있다.\r\n  // ...\r\n});</code>\n        </deckgo-highlight-code>\n<br/>\n<p>타입스크립트에서는 컴파일 타임에 DOM에 접근할 수 없고, 뭐가 정확히 튀어나오는지 모르기 때문에 우리가 타입 단언을 해주어야 문제 없이 사용할 수 있다.</p>\n<p>그리고 타입 단언은 서브타입에서만 쓸 수 있다고 한다! 사실 그 외에 써본 적이 없어서 해당 오류를 마주한 적이 없었다.</p>","frontmatter":{"date":"January 14, 2023","slug":"/blog/effective-typescript-review","title":"이펙티브 타입스크립트","subtitle":"이펙티브 타입스크립트에서 인상적이었던 내용들"}}},"pageContext":{"id":"9761aff4-ac96-582d-803f-940e7398151e","frontmatter__slug":"/blog/effective-typescript-review","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["1865044719","2228436175","326441978"],"slicesMap":{}}