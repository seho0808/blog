{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/redis-valkey-usage/","result":{"data":{"markdownRemark":{"html":"<h2><strong>Delving into use cases of Redis/Valkey</strong></h2>\n<p class=\"text-time\">Initial Upload 2025-08-24 / Last Modified 2025-08-24</p>\n<p><em><span class=\"text-purple\">I am a newbie in key–value stores but wanted to share the use cases I learned from the last few weeks of experience.</span></em></p>\n<p>There are three main use cases of Redis/Valkey: <span class=\"text-orange\">NoSQL</span>, <span class=\"text-orange\">Caching</span>, and <span class=\"text-orange\">Distributed Locking</span></p>\n<h2><strong><span class=\"text-skyblue\">1. Caching</span></strong></h2>\n<ul>\n<li>\n<p>Most developers reach for Redis when they need caching. It’s <span class=\"text-orange\">fast</span>, <span class=\"text-orange\">reliable</span>, and works great as a <span class=\"text-orange\">centrally managed data store</span>.</p>\n</li>\n<li>\n<p>The most important topics to study (<span class=\"text-yellow\">Pareto principle — focus on the vital 20%</span>):</p>\n<ol>\n<li>\n<p><span class=\"text-skyblue\">Cache Invalidation &#x26; Consistency</span></p>\n<ul>\n<li>Write Patterns: Write-through, write-around, and write-behind strategies.</li>\n<li>Read Patterns: Cache-aside, read-through</li>\n<li>Event-driven invalidation (pub/sub).</li>\n<li>Keeping the cache and DB in sync.</li>\n</ul>\n</li>\n<li>\n<p><span class=\"text-skyblue\">Expiration &#x26; Eviction</span></p>\n<ul>\n<li>TTL strategies</li>\n<li>Eviction policies(<code class=\"language-text\">LRU</code>, <code class=\"language-text\">LFU</code>, etc.) and tuning <code class=\"language-text\">maxmemory</code>.</li>\n<li>Preventing cache stampedes</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>Q: Invalidation vs. eviction — aren't they the same thing? Why the different terms?</p>\n</li>\n<li>\n<p>A: <span class=\"text-yellow\">Eviction</span> is the <span class=\"text-red\">AUTOMATIC</span> removal of a key:value pair (memory limits, TTL expiry, or an eviction policy like LRU/LFU),\nwhile <span class=\"text-yellow\">invalidation</span> is the <span class=\"text-red\">EXPLICIT</span> removal of data by the application (triggered by an event, like a DB update, to avoid stale data).</p>\n</li>\n</ul>\n<br/>\n<h2><strong><span class=\"text-skyblue\">2. NoSQL</span></strong></h2>\n<ul>\n<li><span class=\"text-yellow\">What? You can use Redis as NoSQL?</span> ...I feel you. I had the exact same feeling when I first encountered the concept.</li>\n<li>As traffic grows, many teams choose a key-value store as the <span class=\"text-orange\">primary data store</span> for specific business logic.</li>\n</ul>\n<h4><span class=\"text-skyblue\">When?</span></h4>\n<ul>\n<li>\"Amazon 90% discount coupon — first 1,000 customers, first-come, first-served\"</li>\n<li>\"Rihanna concert ticket reservation\"</li>\n<li>\"Recording popular ordered items\"</li>\n</ul>\n<h4><span class=\"text-skyblue\">Why?</span></h4>\n<ul>\n<li>These have <span class=\"text-orange\">very high request concurrency</span>.</li>\n<li>BUT they also make updates, which cause each request to <span class=\"text-orange\">hold locks on DB rows</span>.</li>\n<li>That makes the database <span class=\"text-orange\">much less scalable</span>.</li>\n<li>One optimization choice is using a key-value store as the <span class=\"text-orange\">primary data store</span>.</li>\n</ul>\n<h4><span class=\"text-skyblue\">How?</span></h4>\n<ul>\n<li>You can choose from many data structures that Redis/Valkey has to offer.</li>\n<li>If you use Redis/Valkey as the main data store, make sure you consider them as the <span class=\"text-red\">SINGLE SOURCE OF TRUTH</span>.\n<ul>\n<li>For example, if you keep available stock count both on DB and Redis, it can easily become an <span class=\"text-orange\">antipattern</span>.</li>\n<li>One way to prevent a complicated situation is to simply <span class=\"text-skyblue\">remove the column from the DB and only keep it in Redis</span>.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2><strong><span class=\"text-skyblue\">3. Distributed Locking</span></strong></h2>\n<ul>\n<li>I think there are mainly two reasons to use Redis/Valkey distributed locking:\n<ol>\n<li><span class=\"text-yellow\">Application Level Lock.</span> DB locks only protect database state; sometimes you need to coordinate operations at the application layer.</li>\n<li><span class=\"text-yellow\">Reduce backpressure</span> on the DB.</li>\n</ol>\n</li>\n<li>Number 2 is less tempting to me, since there are so many other solutions (Kafka, MQ, etc.).</li>\n<li>Number 1 is somewhat tempting, though you can still use other patterns to achieve it.</li>\n<li>Distributed Lock is a safe choice if you have a <span class=\"text-red\">SINGLE REDIS CLUSTER</span>\n<ul>\n<li>This is because multiple Redis clusters enforce you to use <span class=\"text-skyblue\">Redlock</span>, which is an <span class=\"text-red\">inherently flawed algorithm</span>.</li>\n</ul>\n</li>\n</ul>","frontmatter":{"date":"August 24, 2025","slug":"/blog/redis-valkey-usage","title":"Redis/Valkey Use Cases","subtitle":"Delving into use cases of Redis and Valkey"}}},"pageContext":{"id":"f8accf41-b32c-516e-9614-46c7662a8bcc","frontmatter__slug":"/blog/redis-valkey-usage","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["1865044719","2228436175","326441978"],"slicesMap":{}}